\documentclass{beamer}

\setbeamertemplate{bibliography item}{[\theenumiv]}

\usetheme{Madrid}
%\usecolortheme{seahorse}
\usepackage[brazil]{babel}
\usepackage[utf8x]{inputenc} % acentos diretamente do teclado
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{listings}
%\usepackage{courier}
\usepackage[scaled=0.8]{beramono}

%Box color
%\setbeamercolor{block title example}{fg=blue!50,bg=blue!10}
%\setbeamercolor{block body example}{fg=blue,bg=blue!5}
%\setbeamercolor{block title example}{fg=blue,bg=purple}
%\setbeamercolor{block body example}{fg=blue,bg=blue!5}

\title[Programação Paralela]{Intel Cilk Plus}
\subtitle{Programação Paralela}
\author[Alexandre \and Jeremias \and Matheus]{Alexandre Lucchesi%
    \and Jeremias Moreira%
    \and Matheus Braga}
\institute[UnB]{%
    Departamento de Ciência da Computação\\
    Universidade de Brasília, Brasília -- DF\\[1ex]
    \texttt{alexandrelucchesi@gmail.com}\\
    \texttt{jeremias@aluno.unb.br}\\
    \texttt{matheus.mtb7@gmail.com}\\
}
\date[Outubro, 2014]{10 de outubro de 2014}


\lstset{%
    language=C,
    basicstyle=\ttfamily,
    breaklines=true,
    morekeywords={cilk\_for, cilk\_spawn, cilk\_sync, cilk, grainsize, 
    reducer\_opadd, CILK\_C\_REDUCER\_OPADD, CILK\_C\_REGISTER\_REDUCER,
    REDUCER\_VIEW, CILK\_C\_UNREGISTER\_REDUCER,get\_value,
    \_\_attribute\_\_, vector, \_Cilk\_for}
}

\begin{document}

\begin{frame}[plain]
    \titlepage%
\end{frame}

\begin{frame}[shrink]{Sumário}
    \tableofcontents
\end{frame}

%\section{Introdução}
%\subsection{O que é}
%\begin{frame}{Introdução}
%    \begin{itemize}
%        \item Cilk Plus é ``dahora''~\cite{jeffers:2013}.
%    \end{itemize}
%\end{frame}

\section{História}
\begin{frame}{História do Cilk}
\begin{itemize}
    \item O MIT desenvolveu o Cilk: uma tecnologia para programação
    \textit{multithread};
    \item O Cilk generaliza a semântica do C e introduz novas construções
    sintáticas para permitir a expressão de paralelismo;
    \item \textbf{O programador} deve se concentrar em estruturar seus programas
    de forma a explorar o \textbf{paralelismo} e a \textbf{localidade};
    \item \textbf{O Cilk} deve ser responsável pelo \textbf{escalonamento de
    tarefas} (em tempo de execução) maximizando o desempenho em
    \textbf{diferentes plataformas}.
\end{itemize}
\end{frame}

\begin{frame}{História do Cilk}
\begin{itemize}
    \item Cilk-1: suporte eficiente a \textbf{\textit{work-stealing}};
    \item Cilk-5: extensões simples para \textit{multithread} em ANSI C\@;
    \item Cilk++: versão comercial para C++ que introduziu reduções de
    hiperobjetos como técnica eficiente em aplicações cuja programação é
    irregular (ex: simulações \textit{N-body}, \textit{tree search}, etc);
    \item Cilk Plus: adicionou extensões para matrizes e foi incorporado ao
    compilador da Intel~\footnote{Pouco tempo após o lançamento do Cilk Plus, a
    Intel tornou pública as especificações da linguagem, permitindo sua
    incorporação em outros compiladores. Atualmente, além dos compiladores Intel,
    o Cilk Plus pode ser encontrado em versões do \texttt{gcc} e
    do \texttt{clang} (de forma limitada).}.
\end{itemize}
\end{frame}

\section{Funções Principais}
\subsection{Cilk Plus in a nutshell\ldots}
\begin{frame}{Cilk Plus \textit{in a nutshell}\ldots}
\begin{itemize}
    \item Elementos básicos:
    \begin{itemize}
        \item \texttt{cilk\_for};
        \item \texttt{cilk\_spawn};
        \item \texttt{cilk\_sync}.
    \end{itemize}
    \item Redução com hiperobjetos;
    \item Notação matricial.
\end{itemize}
\end{frame}
\subsubsection{cilk\_for}
\begin{frame}[fragile]{\texttt{cilk\_for}}
\begin{itemize}
    \item Permite que as iterações sejam executadas em paralelo.
\end{itemize}
\begin{block}{Exemplo}
\begin{lstlisting}
void saxpy(float a, float x[], float y[], size_t n) {
    cilk_for (size_t i = 0; i < n; i++)
        y[i] += a * x[i];
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]{\texttt{cilk\_for}}
\begin{columns}[T]
\begin{column}{0.5\textwidth}
\begin{itemize}
    \item A sintaxe do \texttt{cilk\_for} tem algumas limitações, pois deve ser
    possível computar o espaço de iterações antes de executar o \textit{loop};
    \item O \texttt{corpo} deve ser paralelizável;
    \item O tipo de \texttt{idx} deve ser um inteiro ou \textit{iterator} de
    acesso randômico (ex: um ponteiro);
    \item Em \texttt{cond} podem ser utilizados somente: ${ !=, <, >, >=, <= }$;
\end{itemize}
\end{column}

\begin{column}{0.5\textwidth}
\begin{block}{}
\begin{lstlisting}
cilk_for(idx = expr; cond; incr)
    corpo;
\end{lstlisting}
\end{block}
\begin{itemize}
    \item \texttt{incr} é composto de um limite (\texttt{lim}) e um passo que
    devem ser avaliados apenas uma vez (imutáveis);
    \item O incremento (ou decremento) pode ser expressado com ${ +=, -=, ++,
    --}$.
\end{itemize}
\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{\texttt{cilk\_for}}
\begin{itemize}
    \item Como forma de evitar sincronizações execivas, e por padrão, o 
    \texttt{cilk\_for} divide (\textit{tiles}) o espaço de iterações, fazendo 
    com que cada \textit{thread} execute um \textit{tile}.
    \item Para casos onde é necessário maior controle da granularidade,
    pode-se o utilizar o \textbf{\texttt{pragma cilk grainsize}} para
    especificar o tamanho de um \textit{tile}:
\begin{lstlisting}
#pragma cilk grainsize = 1
cilk_for (int i = 0; i < n; i++)
    a[i] = f(b[i]);
\end{lstlisting}
\end{itemize}

\end{frame}
{
\usebackgroundtemplate{%
\tikz[overlay,remember picture] \node[opacity=0.025, at=(current page.center)] {
   \includegraphics[height=\paperheight,width=\paperwidth]{img/spawn.jpg}};
}
\subsubsection{cilk\_spawn}
\begin{frame}[fragile]{\texttt{cilk\_spawn}}
\begin{itemize}
    \item O \texttt{cilk\_spawn} cria e executa uma nova \textit{thread}
    de \textbf{forma assíncrona};
    \item Possui mecanismos que possibilitam a recuperação do valor de retorno
    da chamada~\footnote{Os argumentos passados para a função são
    avaliados antes do \textit{fork} (\textit{strict evaluation}).}:
\begin{lstlisting}
x = cilk_spawn f(*p++);
\end{lstlisting}
    \item É possível criar chamadas assíncronas de um conjunto de instruções
    através de \textbf{expressões lambda}:
\begin{lstlisting}
cilk_spawn [&]{
    for (int i = 0; i < n; i++)
        a[i] = 0;
} ();
\end{lstlisting}
\end{itemize}
\end{frame}
}
\subsubsection{cilk\_sync}
\begin{frame}{\texttt{cilk\_sync}}
\begin{itemize}
    \item O \texttt{cilk\_sync} consiste em um mecanismo de sincronização que se
    assemelha a um \textit{join}.
    \item O escopo de uma chamada \texttt{cilk\_sync} é a função inteira na qual
    foi declarada e existe uma chamada \texttt{cilk\_sync} implícita no final de
    cada função.
    \item Isso implica que todo o paralelismo criado com o Cilk Plus em
    determinada função, termina antes que ela retorne.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\emph{Not only} uma questão de estilo\ldots}
\begin{columns}[c]

\begin{column}{0.3\textwidth}
\begin{block}{Código}
% Bad style...
\begin{lstlisting}
...
cilk_spawn f();
cilk_spawn g();
...
cilk_sync;
...
\end{lstlisting}
\end{block}
\end{column}

\pause

\begin{column}{0.6\textwidth}
\begin{figure}
    \centering
    \includegraphics[width=\columnwidth]{./img/bad-style.png}
\end{figure}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{\emph{Not only} uma questão de estilo\ldots}
\begin{columns}[c]

\begin{column}{0.3\textwidth}
\begin{block}{Código}
% Good style...
\begin{lstlisting}
...
cilk_spawn f();
g();
...
cilk_sync;
...
\end{lstlisting}
\end{block}
\end{column}

\pause

\begin{column}{0.4\textwidth}
\begin{figure}
    \centering
    \includegraphics[width=\columnwidth]{./img/good-style.png}
\end{figure}
\end{column}
\end{columns}
\end{frame}

\subsection{Serial Elision}
\begin{frame}[fragile]{\textit{Serial Elision}}
\begin{itemize}
    \item O Cilk Plus, de uma forma geral, é uma linguagem pouco intrusiva;
    \item Isso fica explícito quando se deseja, por exemplo, obter a versão
    serial (\textit{serial elision}) de um programa Cilk Plus: basta eliminar as
    palavras-chave \texttt{cilk\_spawn}, \texttt{cilk\_sync} e
    \texttt{cilk\_for};
    \item De forma trivial:
\begin{lstlisting}
#define cilk_spawn
#define cilk_sync
#define cilk_for for
\end{lstlisting}
    \item O resultado é um programa serial C/C++ válido.
\end{itemize}
\end{frame}

\subsection{Hiperobjetos}
\begin{frame}[fragile]{Hiperobjetos}
    Hiperojetos possibilitam acesso \textit{thread-safe} a objetos compartilhados, dando a cada \textit{thread} uma instância do objeto.
\begin{columns}[T]
\begin{column}{0.5\textwidth}
\begin{itemize}
    \item São em sua maioria redutores e fornecem uma operação que mecla dois \textit{views} para o redutor. 
\end{itemize}
\begin{footnotesize}
\begin{block}{}
\begin{lstlisting}
    cilk::reducer_opadd<float> sum = 0;
    ...
    cilk_for(size_t i = 1; i < n; i++){
// Atualiza a soma local.
        sum += f(i);
    }
// get_value() retorna a soma global.
    result = sum.get_value(); 
\end{lstlisting}
\end{block}
\end{footnotesize}

\end{column}

\begin{column}{0.4\textwidth}
\begin{footnotesize}
\begin{block}{Redutores}
Lists \\
\qquad list\_append \\
Listas \\
\qquad list\_append, list\_prepend \\
Mínimo e Máximo \\
\qquad max, max\_index, min, min\_index \\
Operadores Matemáticos \\
\qquad add, mul \\
Operadores bit-a-bit \\
\qquad and, or, xor \\
Concatenação de strings \\
\qquad string, wstring \\
Arquivos \\
\qquad ostream
\end{block}
\end{footnotesize}

\end{column}

\end{columns}
\end{frame}

\begin{frame}[fragile]{Hiperobjetos}
    Tais operações possibilitam a utilização de regiões compartilhadas sem o uso de \textit{locks}, com as seguintes características:
\begin{itemize}
	\item Funciona para qualquer operação de redução associativa.
    \item As operações não precisam ser comutativas.
    \item O redutor não necessita ser uma variável local.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Hiperobjetos}
    Hiperobjetos possuem diferentes sintaxes e comportamentos em C e C++.
\begin{columns}[T]
\begin{column}{0.4\textwidth}
\begin{tiny}
\begin{block}{C}
\begin{lstlisting}
CILK_C_REDUCER_OPADD(sum, int, 0);
CILK_C_REGISTER_REDUCER(sum);
cilk_for(int i = 0; i < 6021023; ++i) {
    REDUCER_VIEW(sum) += a[i];
}
CILK_C_UNREGISTER_REDUCER(sum);
printf("Soma: %d\n", REDUCER_VIEW(sum));
\end{lstlisting}
\end{block}
\end{tiny}
\end{column}

\begin{column}{0.4\textwidth}

\begin{tiny}
\begin{block}{C++}
\begin{lstlisting}
cilk::reducer_opadd<int> sum;
cilk_for (int i = 0; i < 6021023; i++) {
    sum += i;
}
printf("Soma: %d\n",sum.get_value());
\end{lstlisting}
\end{block}
\end{tiny}

\end{column}
\end{columns}
\end{frame}

\subsection{Notações Matriciais e Funções Elementares}

\begin{frame}{Notações Matriciais e Funções Elementares}
\begin{block}{}
\centering
    O Cilk Plus estende o C/C++ para utilizar Notações Matriciais e Funções 
    Elementares, o qual permite ao programador especificar seções de uma matriz 
    da qual será realizado o acesso. Tal notação auxilia o compilador na 
    realização de vetorização e autoparalelização.
\end{block}
\end{frame}

\subsubsection{Notações Matriciais}
\begin{frame}{Notações Matriciais}
\begin{block}{Expressões de Seção}
    Forma de selecionar múltiplos \textit{arrays} de elementos para operações de dados paralela.
\begin{block}{Sintaxe}
    \texttt{[Início:tamanho:passo]}
\end{block}
    A respectiva tripla representa uma sequência de valores subscritos a partir 
    do \textbf{início}, com $n$ elementos de \textbf{tamanho}, onde cada um 
    distancia-se pelo \textbf{passo}, utilizando a seguinte fórmula:
\begin{block}{}
    \centering
\begin{small}
    \texttt{início, início$+$passo, início$+$passo$*2$,$\ldots$, início$+$passo$*$(tamanho$-1$)}
\end{small}
\end{block}
\end{block}

\end{frame}

\begin{frame}{Notações Matriciais}
\begin{block}{Expressões de Seção}
    Expressões de Seção seguem as seguintes regras:
\begin{itemize}
    \item Se não há passo, o valor do mesmo é 1.
	\item Se a tripla não contém expressões, o valor de início é $0$ e o 
	valor de tamanho é o número de elementos contidos no \textit{array}.
	\item Se o passo é negativo, o valor de início apontara para o índice mais alto.
	\item Se o tamanho $\leq 0$, a sequência é vazia.
\end{itemize}
\end{block}

\end{frame}

\begin{frame}[fragile]{Notações Matriciais}
\framesubtitle{Expressões de Seção}
    Cada Expressão de Seção possui um rank que ditam as regras de operações que
    podem ser realizadas com aquele \textit{array}.~\footnote{São diversas as
    regras a respeitos de Expressões de Seção e foge ao escopo do Seminário,
    que é uma apresentação superficial sobre a ferramenta, explorá-las}
\begin{scriptsize}
\begin{block}{Exemplos de Expressões de Seção}
\begin{verbatim}
    int *ponteiro;
    int Matriz[i][j];
\end{verbatim}
\pause
\begin{verbatim}
    ponteiro[:] = ...; // Não é uma operação válida por não haver tamanho declarado.
\end{verbatim}
\pause
\begin{verbatim}
    matriz[:][:] = ...; // matriz bidimensional.
\end{verbatim}
\pause
\begin{verbatim}
    ponteiro[1:5] = ...; // ponteiro[1],ponteiro[2], ... ponteiro[5].
\end{verbatim}
\pause
\begin{verbatim}
    matriz[0:5][0:7]; 	// Referem-se aos 35 elementos de uma matriz bidimensional.
\end{verbatim}
\end{block}
\end{scriptsize}
\end{frame}
{
\renewcommand{\footnotesize}{\tiny} 

\begin{frame}[fragile]{Notações Matriciais}
\framesubtitle{Operações com Expressões de Seção}
    É uma operação paralela para modificar elementos da seção da matriz do lado
    esquerdo.\footnote{Se a operação do lado direito não se associa diretamente
    com os elementos do lado esquerdo, a substituição não é completa e o
    comportamento é indefinido}
\begin{tiny}
\begin{block}{Atribuição}
\begin{verbatim}
    a[0:10] = a[10:10];		// sem sobreposição; bem definida
    a[0:10:2] = a[1:10:2];	// sem sobreposição; bem definida
    a[0:10] = a[0:10] + 1;	// com sobreposição; bem definida
    a[0:10] = a[1:10]; 		// sobreposição incompleta; comportamento indefinido
\end{verbatim}
\end{block}
\pause
\begin{block}{Operações Aritméticas}
\begin{columns}
\begin{column}{0.17\textwidth}
\begin{tiny}
\begin{block}{}
\begin{verbatim}
A[:] = 1.0;	
A[0:3][0:3] = B[0];
C[:] = A[:] + B[:];
\end{verbatim}
\end{block}
\end{tiny}
\end{column}
\pause
\begin{column}{0.42\textwidth}
\begin{tiny}
\begin{block}{}
\begin{verbatim}
C[20:10] = A[10:10] + B[0:10];
C[20:10][0] = A[10:10][2] + B[0:10][3];
C[0:9][0][0:9] = A[0][0:9][0:9] + B[0:9][0:9][4];
\end{verbatim}
\end{block}
\end{tiny}
\end{column}
\end{columns}
\pause
\begin{columns}
\begin{column}{0.75\textwidth}
\begin{tiny}
\begin{block}{}
\begin{verbatim}
    A[:] *= 2;
    A[:]++;
    A[:] = B[:] == C[:];
\end{verbatim}
\pause
\begin{verbatim}
    A[0:2][0:2] = B[0:2]; // Erro! Problema quanto ao número de dimensões!\\
\end{verbatim}
\end{block}
\end{tiny}
\end{column}
\end{columns}
\end{block}
\end{tiny}
\end{frame}
}
\begin{frame}[fragile]{Notações Matriciais}
\framesubtitle{Chamadas de função}
   A chamada de uma função utilizando uma expressão de seção mapeia chamadas com os elementos sucessivos da mesma.

\begin{block}{Função Escalar}
\begin{lstlisting}
void funcaoEscalarQualquer(int i) {
    printf ("%3d ", i);
}
\end{lstlisting}
\end{block}
\pause
\begin{scriptsize}
\begin{columns}
\begin{column}{0.4\textwidth}
\begin{block}{Versão escalar} 
\begin{lstlisting}
for(int i = 0; i < n; i++){
    funcaoEscalarQualquer(a[i]);
}
\end{lstlisting}
\end{block}
\pause
\end{column}
\begin{column}{0.55\textwidth}
\begin{block}{Versão escalar com notação matricial} 
\begin{lstlisting}
    funcaoEscalarQualquer(a[:]);
\end{lstlisting}
\end{block}
\end{column}

\end{columns}
\end{scriptsize}
\end{frame}

\begin{frame}[fragile]{Notações Matriciais}
\framesubtitle{Operações de Redução}
	Operações de redução em Notações Matriciais funcionam de forma similar
	aquelas existentes nas hiperoperações, sendo executadas para a seção
	estipulada do \textit{array}.
\begin{block}{Lista de Operações de Redução}
\begin{small}
\begin{small}
\begin{columns}
\begin{column}{0.45\textwidth}
\begin{itemize}
    \item \_\_sec\_reduce\_add
    \item \_\_sec\_reduce\_mul
    \item \_\_sec\_reduce\_max
    \item \_\_sec\_reduce\_min
    \item \_\_sec\_reduce\_max\_ind
\end{itemize}
\end{column}
\begin{column}{0.45\textwidth}
\begin{itemize}
    \item \_\_sec\_reduce\_min\_ind
    \item \_\_sec\_reduce\_all\_zero
    \item \_\_sec\_reduce\_all\_nonzero
    \item \_\_sec\_reduce\_any\_zero
    \item \_\_sec\_reduce\_any\_nonzero
\end{itemize}
\end{column}
\end{columns}
\end{small}
\end{small}
\end{block}
\end{frame}

\subsubsection{Funções Elementares}
\begin{frame}{Funções Elementares}
    Funções Elementares são construções que podem ser invocadas tanto em argumentos escalares quanto em elementos de uma matriz em paralelo.
    Ocorre em três etapas:
\begin{enumerate}
    \item É escrito uma função que utiliza valores escalares de uma operação para um único elemento.
\pause
    \item Adiciona-se um atributo ao vetor para que o compilador gere uma variante vetorizada da função.
\pause
    \item Chama-se a função que irá operar em vários valores de uma só vez.
\end{enumerate}

\end{frame}

\begin{frame}{Funções Elementares}
\begin{block}{Semântica}
    Sua ordem de execução é fora da ordem da sua sequência de invocação, 
\end{block}
\begin{block}{Atributo \textit{vector}}
    De uso geral para que o compilador gere a versão vetorial da função.
\end{block}
\begin{block}{Cláusula \textit{processor}}
    Direciona a versão vetorizada que o compilador irá criar para um arquitetura específica.
\end{block}
\begin{block}{Cláusula \textit{vectorlength}}
    ( EXPLIQUEM ESSA PRA MIM, PLS!!!)
\end{block}
\end{frame}
\begin{frame}{Funções Elementares}
\begin{block}{Cláusula \textit{uniform}}
    Argumentos que podem ser distribuídos para todas a iterações.
\end{block}
\begin{block}{Cláusula \textit{linear}}
    Invocações consecutivas seguem padrões nos parâmetros.
\end{block}
\begin{block}{Cláusula \textit{mask}}
    O compilador gera uma máscara no vetor da execução.
\end{block}
\end{frame}

\begin{frame}[fragile]{Funções Elementares}
\framesubtitle{Exemplo}
\begin{scriptsize}
\begin{block}{Exemplo}
\begin{block}{Função Elementar}
\begin{lstlisting}
__attribute__((vector)) double ef_add (double x, double y){
  return x + y;
}
\end{lstlisting}
\end{block}
\begin{columns}
\begin{column}{0.4\textwidth}
\begin{block}{Notação Matricial}
\begin{lstlisting}
a[:] = ef_add(b[:],c[:]);
\end{lstlisting}
\end{block}

\end{column}
\begin{column}{0.4\textwidth}
\begin{block}{Construção Cilk}
\begin{lstlisting}
_Cilk_for (j = 0; j < n; ++j) {
  a[j] = ef_add(b[j],c[j])
}
\end{lstlisting}
\end{block}
\end{column}
\end{columns}

\end{block}
\end{scriptsize}
\end{frame}

\subsection{Single Instruction Multiple Data}

\begin{frame}[fragile]{\textit{SIMD}}
\begin{itemize}
     \item O Cilk Plus possui suporte para SIMD de forma fácil.
     \item Possibilidade de vetorizar uma função e dizer ao compilador que um segmento deve ser vetorizado
     \item Usando simplesmente 2 diretivas:
\begin{lstlisting}
__declspec (vector)
#pragma simd [attr]
\end{lstlisting}
\end{itemize}
\end{frame}


\begin{frame}{\_\_declspec (vector)}
Considerando uma função de multiplicação de a e b
\begin{block}{}
    float sum(float a,float b)\{ \\
	return a * b; \\
\}
\end{block}
Para que a soma seja aplicada a um vetor é necessário um for para percorrer todos o elementos
\begin{block}{}
    for (int i=0;i<SIZE;i++)\{ \\
	c[i] = sum(a[i],b[i]); \\
   \}
\end{block}
\end{frame}
\begin{frame}[fragile]{\_\_declspec (vector)}
Da mesma forma e possivel vetorizar essa ou outra funco usando \_\_declspec (vector) 
\begin{block}{}
     \_\_declspec (vector) float sum(float a,float b) \{ \\
	return a * b;\\
\} \\
/* etc */ \\
c[:] = sum(a[:],b[:]);
\end{block}

\end{frame}

\begin{frame}[fragile]{\texttt{\#pragma simd}}
\begin{itemize}
	\item O \#pragma simd diz ao compilador que o proximo blocco a ser executado deve ser vetorizado
	\item Cabe ao compilador decidir de há dependencia de dados	
\end{itemize}
\begin{block}{}
\begin{lstlisting}
#pragma simd
for (int i = 0; i < SIZE; i++) { 
    c[i] = a[i] + b[i]; 
}
\end{lstlisting}
\end{block}
\end{frame}


\begin{frame}[fragile]{\texttt{Atributos}}
 Existem atributos que podem ser usados tanto no \_\_declspec (vector) quanto no pragma \\
São usados seguindo a sintaxe exemplo\\
\#pragma simd reduction(+:sum)
\begin{itemize}
	\item \texttt{vectorlength(n1[, n2]...)}  \\
		 Deve ser multiplo de 2. Define quantas iterações serão usada para cada parametro
	\item \texttt{vectorlengthfor(data type)} \\
		O parametro deve ser padrão (int,float, double) \\
		Resume-se a VEC\_SIZE/sizeof(data\_type) sendo o resultado\\
		aplicado como efeito do vectorlenght
	\item \texttt{private(var1[, var2]...)} \\
		Define as variaveis como privadas em cada ciclo
\end{itemize}
\end{frame}

\begin{frame}[fragile]{\texttt{Atributos}}
\begin{itemize}
	\item firstprivate(var1[, var2]...) \\
		Funciona como o private, mas o valor inicial da variavel é atribuido a todas as iterações
		paralelas.
	\item lastprivate(var1[, var2]...)
		Funciona como o private, mas o valor da utima iteração é atribuido a variavel após
		a execução.
	\item linear(var1:step1 [,var2:step2]...)
		A cada iteração var1 é incrementada em step.
		var1 =+ step1; var2 += step2 ...
	\item reduction(oper:var1 [,var2]…)
		Faz uma redução tendo um operando e uma ou mais váriaveis.
\end{itemize}
\end{frame}

\subsection{Exemplos}
\begin{frame}{Exemplos}
\end{frame}

\begin{frame}{Análise Comparativa}
\section{Análise Comparativa}
\subsection{Gráfico de \protect\textit{Speedup}}
\end{frame}

\section{Aspectos da Ferramenta}
\subsection{Vantagens}
\begin{frame}{Vantagens}
\begin{itemize}
    \item Diretivas básicas bem definidas e de uso trivial;
    \item \textit{Syntactic sugar} para manipulação de \textit{arrays};
    \item Focada em otimizar resultados em processadores da
    Intel\textsuperscript{\textregistered};
    \item Implementa SIMD;
    \item Proporciona um meio onde o programador não precisa se preocupar com
    quase nada.
\end{itemize}
\end{frame}


\subsection{Desvantagens}
\begin{frame}{Desvantagens}
\begin{itemize}
    \item Dificuldade de se instalar;
% Esse ítem aqui acho que tá errado, já que ela usa Serial Elision e funciona de forma similar ao OPENMP
%    \item Muito invasiva, necessita de modificações no compilador e faz alterações na própria sintaxe.
    \item Manipulação de recursos (ex.: \textit{workers}) não é nativa da
    ferramenta.
% COMENTAR, MAS NÃO ESCREVER ISSO EXPLICITAMENTE - São necessárias verdadeiras gambiarras para modificar, por exemplo, o número de threads.
    \item Complicado de se otimizar.
\end{itemize}

\end{frame}

\begin{frame}
teste de bibliografia\cite{doge}
\end{frame}

\section{Conclusão}
\begin{frame}%[allowframebreaks]
    \frametitle{Referências Bibliográficas}
    \tiny{\bibliographystyle{abbrv}}
    \bibliography{refs}
\end{frame}

\end{document}

